<?php
namespace UmutPHP\WPVulnerabilityCheck;

class Manager
{
    CONST WPVULNDB_V3_URL = 'https://wpvulndb.com/api/v3/';
    /**
     * @param Settings $settings
     * @return bool
     * @throws Exception\NotExistsPath
     */
    public function check(Settings $settings)
    {
        if (!is_dir($settings->path)) {
            echo PHP_EOL;
            echo "Invalid folder is given.";
            echo PHP_EOL . PHP_EOL;
            throw new \Exception("Invalid folder is given.");
        }

        $files   = scandir($settings->path);
        $plugins = array();
        foreach ($files as $key => $value) {
            if ($value === '.' || $value === '..' || $value === 'index.php') {
                continue;
            }

            if (is_dir($settings->path . DIRECTORY_SEPARATOR . $value)) {
                if (file_exists($settings->path . DIRECTORY_SEPARATOR . $value . DIRECTORY_SEPARATOR . $value . ".php")) {
                    $plugins[$value] = $value . DIRECTORY_SEPARATOR . $value . ".php";
                }
                
                continue;
            }

            $plugins[str_replace('.php', '', $value)] = $value;
        }

        /** @var Result[] $results */
        $results           = array();
        $startTime         = microtime(true);
        $checkedPlugins    = 0;
        $vulnerablePlugins = 0;
        $results           = array();
        $totalPluginCount  = count($plugins);
        $failResult        = array();
        
        echo PHP_EOL;
        echo "Checking " . ($totalPluginCount === 1 ? 'plugin' : 'plugins') . "...";
        echo PHP_EOL . PHP_EOL;
        foreach ($plugins as $plugin => $file) {
            try {
                $checkedPlugins++;
                $vulResult = $this->checkPlugin($plugin, $file, $settings);

                if (!isset($vulResult[$plugin])) {
                    echo ".";
                    continue;
                }

                // Get Vulnerabilities and check the plugin with version
                if (count($vulResult[$plugin]['vulnerabilities'])) {
                    $vulnerablePlugins++;
                    echo "v"; // For vulnerability
                } else {
                    echo "."; // For success
                    continue;
                }
                
                $results      = array_merge($results, $vulResult);
            } catch (\Exception $e) {
                echo "f"; // Fail
                $pluginResult = array(
                    $plugin => array("message" => $e->getMessage())
                );
                $failResult   = array_merge($failResult, $pluginResult);
            }
        }

        $runTime = round(microtime(true) - $startTime, 1);

        echo PHP_EOL . PHP_EOL;

        $message = "Checked $checkedPlugins plugins in $runTime second, ";
        if ($vulnerablePlugins === 0) {
            $message .= "no vulnerability found.";
        } else {
            $message .= "some vulnerability(s) in $vulnerablePlugins ";
            $message .= ($vulnerablePlugins === 1 ? 'plugin.' : 'plugins.');
        }

        echo $message . PHP_EOL;

        if (!empty($results)) {
            if ($settings->output != 'NO') {
                $this->output($results);
            }

            return false;
        }

        return true;
    }

    /**
     * Check the vulnerabities array and remove the fixed bugs
     *
     * @param array $result Result array for the plugin
     * @param string $version Version the plugin to be checked
     * @return array
     */
    public function checkVulnerabilityWithVersion($result, $version)
    {
        foreach ($result['vulnerabilities'] as $key => $value) {
            if ($version > $value['fixed_in']) {
                unset($result['vulnerabilities'][$key]);
            }
        }

        return $result;
    }

    /**
     * Check plugin with plugin name via API
     *
     * @param string $pluginName
     * @param string $pluginFile
     * @param Settings $settings
     * @return Result[]
     * @throws Exception
     */
    public function checkPlugin($pluginName, $pluginFile, Settings $settings = null)
    {
        if ($settings === null) {
            $settings = new Settings();
        }

        $meta = $this->getPluginMetaData(
            $settings->path . DIRECTORY_SEPARATOR . $pluginFile
        );

        $vulnerabilities = $this->get($pluginName, $settings->token);

        if (!isset($vulnerabilities[$pluginName])) {
            throw new \Exception($vulnerabilities["error"], 1);
        }

        $vulnerabilities[$pluginName] = $this->checkVulnerabilityWithVersion($vulnerabilities[$pluginName], $meta['Version']);

        return $vulnerabilities;
    }

    /**
     * Get plugin meta data from the header comment block
     * 
     * @param string $file File path of the plugin file
     * @return array The array of the meta values 
     */
    private function getPluginMetaData($file)
    {
        $all_headers = array(
           'Name'        => 'Plugin Name',
           'PluginURI'   => 'Plugin URI',
           'Version'     => 'Version',
           'Description' => 'Description',
           'Author'      => 'Author',
           'AuthorURI'   => 'Author URI',
           'TextDomain'  => 'Text Domain',
           'DomainPath'  => 'Domain Path',
           'Network'     => 'Network',
           // Site Wide Only is deprecated in favor of Network.
           '_sitewide'   => 'Site Wide Only'
         );
        // We don't need to write to the file, so just open for reading.
        $fp = fopen($file, 'r');
     
        // Pull only the first 8kiB of the file in.
        $file_data = fread($fp, 8192);
     
        // PHP will close file handle, but we are good citizens.
        fclose($fp);
     
        // Make sure we catch CR-only line endings.
        $file_data = str_replace("\r", "\n", $file_data);
     
        foreach ($all_headers as $field => $regex) {
            if (preg_match( '/^[ \t\/*#@]*' . preg_quote($regex, '/') . ':(.*)$/mi', $file_data, $match) && $match[1])
                $all_headers[$field] = trim(preg_replace("/\s*(?:\*\/|\?>).*/", '', $match[1]));
            else
                $all_headers[$field] = '';
        }
     
        return $all_headers;
    }

    /**
     * Private function to get the result from the API
     *
     * @param string $pluginName
     * @param string $APIToken
     * @return array Array decoded from JSON string
     */
    private function get($pluginName, $APIToken) {
        $ch  = curl_init();
        $url = self::WPVULNDB_V3_URL . 'plugins/' . $pluginName;

        curl_setopt($ch, CURLOPT_URL, $url);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);

        $headers = array(
            'Authorization: Token token=' . $APIToken
        );

        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);

        $server_output = curl_exec ($ch);

        curl_close ($ch);
        $return = json_decode($server_output, true);

        return $return;
    }

    /**
     * Print result list
     * 
     * @param array $results
     * @return void
     */
    private function output($results) {
        echo PHP_EOL;
        echo str_repeat('-', 60);
        echo PHP_EOL;
        echo "Vulnerability Details";
        echo PHP_EOL;
        echo PHP_EOL;
        $i = 1;
        foreach ($results as $plugin => $vulnerabilities) {
            echo $i . ") " . $plugin . ":";
            $j = 1;
            foreach ($vulnerabilities["vulnerabilities"] as $key => $vuln) {
                echo PHP_EOL;
                echo "\t" . $j . ") id: " . $vuln["id"] . ", " .  $vuln["title"];
                echo ", Fixed in Version " . $vuln["fixed_in"] . "." . PHP_EOL;
                echo "\tReferences: " . implode(", ", $vuln["references"]["url"]);
                echo PHP_EOL;
                $j++;
            }
            $i++;
            echo PHP_EOL;
        }
    }
}
