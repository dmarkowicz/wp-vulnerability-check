<?php
namespace UmutPHP\WPVulnerabilityCheck;

class Manager
{
    CONST WPVULNDB_V3_URL = 'https://wpvulndb.com/api/v3/';

    private $settings;

    /**
     * @param Settings $settings
     */
    public function __construct(Settings $settings = null) {
        if ($settings instanceof Settings) {
            $this->settings = $settings;
        }
    }

    /**
     * Main check function
     * 
     * @param Settings|null $settings
     * @param Output|null $output
     * @return bool
     * @throws Exception\NotExistsPath
     */
    public function check(Settings $settings = null, Output $output = null)
    {
        if ($settings instanceof Settings) {
            $this->settings = $settings;
        }

        if ($output === null) {
            $writer = null;

            if ($this->settings->output === 'HTML') {
                $writer = new Writer\HTML();
            }

            if ($this->settings->colors === true) {
                $output = new OutputColored($writer);
            } else {
                $output = new Output($writer);
            }
        }

        $returnW = $this->checkWordPress($this->settings, $output);
        $returnP = $this->checkPlugins($this->settings, $output);
        $returnT = $this->checkThemes($this->settings, $output);

        return $returnW && $returnP && $returnT;
    }

   /**
    * Check if the directory exists
    * 
    * @param string $directory
    * 
    * @throws Exception\NotExistsPath
    */
    private function checkDirectory($directory)
    {
        if (!is_dir($directory)) {
            $output->writeNewLine();
            $output->writeLine("Invalid folder is given.");
            $output->writeNewLine();
            throw new \Exception("Invalid folder is given.");
        }
    }

    /**
     * Private WordPress installation check function
     *
     * @param Settings $settings
     * @param Output $output
     * @return bool
     * @throws Exception\NotExistsPath
     */
    private function checkWordPress(Settings $settings, Output $output)
    {
        $this->checkDirectory($this->settings->path);
        $version_file = $this->settings->path . DIRECTORY_SEPARATOR .
        "wp-includes" . DIRECTORY_SEPARATOR . "version.php";

        if (!file_exists($version_file)) {
            $output->writeNewLine();
            $output->writeLine("Invalid installation folder is given.");
            $output->writeNewLine();
            throw new \Exception("Invalid installation folder is given.");
        }

        include_once $version_file;

        if (!isset($wp_version)) {
            $output->writeNewLine();
            $output->writeLine("No valid WordPress version is found.");
            $output->writeNewLine();
            throw new \Exception("No valid WordPress version is found.");
        }

        $output->writeLine(
            "Checking WordPress version ..."
        );
        $output->writeNewLine();

        $version = implode('', explode('.', $wp_version));

        $vulResult = $this->checkWordPressVersion($version, $settings);

        if (!isset($vulResult[$wp_version])) {
            $output->ok(); // For success
        }

        // Get Vulnerabilities and check the WordPress with version
        if (count($vulResult[$wp_version]['vulnerabilities'])) {
            $output->error(); // For vulnerability
        } else {
            $output->ok(); // For success
        }

        if (!empty($vulResult)) {
            if ($this->settings->output != 'NO') {
                $this->output($vulResult, $output);
            }

            return false;
        }

        return true;
    }

    /**
     * Private theme check function
     *
     * @param Settings $settings
     * @param Output $output
     * @return bool
     * @throws Exception\NotExistsPath
     */
    private function checkThemes(Settings $settings, Output $output)
    {
        $this->checkDirectory($this->settings->themes);

        $files  = scandir($this->settings->themes);
        $themes = array();

        foreach ($files as $key => $value) {
            if (!$this->isComponent($value)) {
                continue;
            }

            if (is_dir($this->settings->themes . DIRECTORY_SEPARATOR . $value)) {
                if (file_exists($this->settings->themes . DIRECTORY_SEPARATOR . $value . DIRECTORY_SEPARATOR . "index.php")) {
                    $themes[$value] = $value;
                }
            }
        }

        /** @var Result[] $results */
        $results          = array();
        $startTime        = microtime(true);
        $checkedThemes    = 0;
        $vulnerableThemes = 0;
        $totalThemeCount  = count($themes);
        $failResult       = array();
        
        $output->setTotalPluginCount($totalThemeCount);
        $output->writeNewLine();
        $output->writeLine(
            "Checking " . ($totalThemeCount === 1 ? 'theme' : 'themes') . "..."
        );
        $output->writeNewLine();
        foreach ($themes as $theme => $file) {
            try {
                $checkedThemes++;
                $vulResult = $this->checkTheme($theme, $file, $this->settings);

                if (!isset($vulResult[$theme])) {
                    $output->ok(); // For success
                    continue;
                }

                // Get Vulnerabilities and check the plugin with version
                if (count($vulResult[$theme]['vulnerabilities'])) {
                    $vulnerableThemes++;
                    $output->error(); // For vulnerability
                } else {
                    $output->ok(); // For success
                    continue;
                }
                
                $results      = array_merge($results, $vulResult);
            } catch (\Exception $e) {
                $output->ok(); // Fail but means no vuşnerability in DB or custom plugin
                $pluginResult = array(
                    $theme => array("message" => $e->getMessage())
                );
                $failResult   = array_merge($failResult, $pluginResult);
            }
        }

        $runTime = round(microtime(true) - $startTime, 1);

        $output->writeNewLine(2);

        $message = "Checked $checkedThemes " . ($checkedThemes === 1 ? 'theme' : 'themes') . " in $runTime second, ";
        if ($vulnerableThemes === 0) {
            $message .= "no vulnerability found.";
        } else {
            $message .= "found some vulnerability(s) in $vulnerableThemes ";
            $message .= ($vulnerableThemes === 1 ? 'theme.' : 'themes.');
        }

        $output->writeLine($message);

        if (!empty($failResult)) {
            $message = "The " . (count($failResult) === 1 ? 'theme which is not ' : 'themes which are not ');
            $message .= "in WPScan Vulnerability Database; " . implode(", ", array_keys($failResult)). ".";
            $output->writeNewLine();
            $output->writeLine($message);
            $output->writeLine("PS: You can exclude your custom themes with --exclude parameter.");
        }

        if (!empty($results)) {
            if ($this->settings->output != 'NO') {
                $this->output($results, $output);
            }

            return false;
        }

        return true;
    }

    /**
     * Private plugin check function
     *
     * @param Settings $settings
     * @param Output $output
     * @return bool
     * @throws Exception\NotExistsPath
     */
    private function checkPlugins(Settings $settings, Output $output)
    {
        $this->checkDirectory($this->settings->plugins);

        $files   = scandir($this->settings->plugins);
        $plugins = array();
        foreach ($files as $key => $value) {
            if (!$this->isComponent($value)) {
                continue;
            }

            if (is_dir($this->settings->plugins . DIRECTORY_SEPARATOR . $value)) {
                if (file_exists($this->settings->plugins . DIRECTORY_SEPARATOR . $value . DIRECTORY_SEPARATOR . $value . ".php")) {
                    $plugins[$value] = $value . DIRECTORY_SEPARATOR . $value . ".php";
                }
                
                continue;
            }

            $plugins[str_replace('.php', '', $value)] = $value;
        }

        /** @var Result[] $results */
        $results           = array();
        $startTime         = microtime(true);
        $checkedPlugins    = 0;
        $vulnerablePlugins = 0;
        $totalPluginCount  = count($plugins);
        $failResult        = array();
        
        $output->setTotalPluginCount($totalPluginCount);
        $output->writeNewLine();
        $output->writeLine(
            "Checking " . ($totalPluginCount === 1 ? 'plugin' : 'plugins') . "..."
        );
        $output->writeNewLine();
        foreach ($plugins as $plugin => $file) {
            try {
                $checkedPlugins++;
                $vulResult = $this->checkPlugin($plugin, $file, $this->settings);

                if (!isset($vulResult[$plugin])) {
                    $output->ok(); // For success
                    continue;
                }

                // Get Vulnerabilities and check the plugin with version
                if (count($vulResult[$plugin]['vulnerabilities'])) {
                    $vulnerablePlugins++;
                    $output->error(); // For vulnerability
                } else {
                    $output->ok(); // For success
                    continue;
                }
                
                $results      = array_merge($results, $vulResult);
            } catch (\Exception $e) {
                $output->ok(); // Fail but means no vuşnerability in DB or custom plugin
                $pluginResult = array(
                    $plugin => array("message" => $e->getMessage())
                );
                $failResult   = array_merge($failResult, $pluginResult);
            }
        }

        $runTime = round(microtime(true) - $startTime, 1);

        $output->writeNewLine(2);

        $message = "Checked $checkedPlugins plugins in $runTime second, ";
        if ($vulnerablePlugins === 0) {
            $message .= "no vulnerability found.";
        } else {
            $message .= "found some vulnerability(s) in $vulnerablePlugins ";
            $message .= ($vulnerablePlugins === 1 ? 'plugin.' : 'plugins.');
        }

        $output->writeLine($message);

        if (!empty($failResult)) {
            $message = "The " . (count($failResult) === 1 ? 'plugin which is not ' : 'plugins which are not ');
            $message .= "in WPScan Vulnerability Database; " . implode(", ", array_keys($failResult)). ".";
            $output->writeNewLine();
            $output->writeLine($message);
            $output->writeLine("PS: You can exclude your custom plugins with --exclude parameter.");
        }

        if (!empty($results)) {
            if ($this->settings->output != 'NO') {
                $this->output($results, $output);
            }

            return false;
        }

        return true;
    }

    /**
     * Return true if the filename is most probably a plugin
     * 
     * @param string $plugin File name
     * @return boolean
     */
    public function isComponent($plugin) {
        if ($plugin === '.' || $plugin === '..' || $plugin === 'index.php') {
            return false;
        }

        if (is_array($this->settings->excluded)) {
            if (in_array($plugin, $this->settings->excluded)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Check the vulnerabities array and remove the fixed bugs
     *
     * @param array $result Result array for the plugin
     * @param string $version Version the plugin to be checked
     * @return array
     */
    public function checkVulnerabilityWithVersion($result, $version)
    {
        foreach ($result['vulnerabilities'] as $key => $value) {
            if ($version > $value['fixed_in']) {
                unset($result['vulnerabilities'][$key]);
            }
        }

        return $result;
    }

    /**
     * Check WordPress with version via API
     *
     * @param string $version
     * @param Settings $settings
     * @return Result[]
     * @throws Exception
     */
    public function checkWordPressVersion($version, Settings $settings = null)
    {
        if ($settings instanceof Settings) {
            $this->settings = $settings;
        }

        $vulnerabilities = $this->get($version, $this->settings->token, 'wordpresses');

        return $vulnerabilities;
    }

    /**
     * Check theme with theme name via API
     *
     * @param string $themeName
     * @param string $themeFile
     * @param Settings $settings
     * @return Result[]
     * @throws Exception
     */
    public function checkTheme($themeName, $themeFile, Settings $settings = null)
    {
        if ($settings instanceof Settings) {
            $this->settings = $settings;
        }

        $meta = $this->getThemeMetaData(
            $this->settings->themes . DIRECTORY_SEPARATOR . $themeFile
        );

        $vulnerabilities = $this->get($themeName, $this->settings->token, 'themes');

        if (!isset($vulnerabilities[$themeName])) {
            throw new \Exception($vulnerabilities["error"], 1);
        }

        $vulnerabilities[$themeName] = $this->checkVulnerabilityWithVersion($vulnerabilities[$themeName], $meta['Version']);

        return $vulnerabilities;
    }

    /**
     * Check plugin with plugin name via API
     *
     * @param string $pluginName
     * @param string $pluginFile
     * @param Settings $settings
     * @return Result[]
     * @throws Exception
     */
    public function checkPlugin($pluginName, $pluginFile, Settings $settings = null)
    {
        if ($settings instanceof Settings) {
            $this->settings = $settings;
        }

        $meta = $this->getPluginMetaData(
            $this->settings->plugins . DIRECTORY_SEPARATOR . $pluginFile
        );

        $vulnerabilities = $this->get($pluginName, $this->settings->token);

        if (!isset($vulnerabilities[$pluginName])) {
            throw new \Exception($vulnerabilities["error"], 1);
        }

        $vulnerabilities[$pluginName] = $this->checkVulnerabilityWithVersion($vulnerabilities[$pluginName], $meta['Version']);

        return $vulnerabilities;
    }

    /**
     * Get theme meta data from the header comment block
     * 
     * @param string $file File path of the plugin file
     * @return array The array of the meta values 
     */
    private function getThemeMetaData($file)
    {
        $all_headers = array(
           'Name'        => 'Theme Name',
           'ThemeURI'    => 'Theme URI',
           'Version'     => 'Version',
           'Description' => 'Description',
           'Author'      => 'Author',
           'AuthorURI'   => 'Author URI',
           'TextDomain'  => 'Text Domain',
           'DomainPath'  => 'Domain Path',
           'Network'     => 'Network',
           // Site Wide Only is deprecated in favor of Network.
           '_sitewide'   => 'Site Wide Only'
         );
        
        return $this->getFileMetaData($all_headers, $file);
    }

    /**
     * Get plugin meta data from the header comment block
     * 
     * @param string $file File path of the plugin file
     * @return array The array of the meta values 
     */
    private function getPluginMetaData($file)
    {
        $all_headers = array(
           'Name'        => 'Plugin Name',
           'PluginURI'   => 'Plugin URI',
           'Version'     => 'Version',
           'Description' => 'Description',
           'Author'      => 'Author',
           'AuthorURI'   => 'Author URI',
           'TextDomain'  => 'Text Domain',
           'DomainPath'  => 'Domain Path',
           'Network'     => 'Network',
           // Site Wide Only is deprecated in favor of Network.
           '_sitewide'   => 'Site Wide Only'
         );
        
        return $this->getFileMetaData($all_headers, $file);
    }

    /**
     * Get file meta data from the header comment block
     * 
     * @param string $file File path of the plugin file
     * @return array The array of the meta values 
     */
    private function getFileMetaData($headers, $file)
    {
        // We don't need to write to the file, so just open for reading.
        $fp = fopen($file, 'r');
     
        // Pull only the first 8kiB of the file in.
        $file_data = fread($fp, 8192);
     
        // PHP will close file handle, but we are good citizens.
        fclose($fp);
     
        // Make sure we catch CR-only line endings.
        $file_data = str_replace("\r", "\n", $file_data);
     
        foreach ($headers as $field => $regex) {
            if (preg_match( '/^[ \t\/*#@]*' . preg_quote($regex, '/') . ':(.*)$/mi', $file_data, $match) && $match[1])
                $headers[$field] = trim(preg_replace("/\s*(?:\*\/|\?>).*/", '', $match[1]));
            else
                $headers[$field] = '';
        }
     
        return $headers;
    }

    /**
     * Private function to get the result from the API
     *
     * @param string $name
     * @param string $APIToken
     * @param string $type
     * @return array Array decoded from JSON string
     */
    private function get($name, $APIToken, $type = "plugins") {
        $ch  = curl_init();
        $url = self::WPVULNDB_V3_URL . $type . '/' . $name;

        curl_setopt($ch, CURLOPT_URL, $url);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);

        $headers = array(
            'Authorization: Token token=' . $APIToken
        );

        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);

        $server_output = curl_exec ($ch);

        curl_close ($ch);
        $return = json_decode($server_output, true);

        return $return;
    }

    /**
     * Print result list
     * 
     * @param array $results
     * @param Output $output
     * @return void
     */
    private function output($results, $output) {
        if ($this->settings->output === 'READABLE') {
            $output->writeNewLine();
            $output->writeLine(str_repeat('-', 60));
            $output->writeLine("Vulnerability Details");
            $output->writeNewLine();
        }

        foreach ($results as $plugin => $vulnerabilities) {
            $output->writeResult($plugin, $vulnerabilities['vulnerabilities']);
        }
    }
}
